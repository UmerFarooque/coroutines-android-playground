<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
    <string name="app_name">coroutines-android-playground</string>

    <string name="coroutines_android_playground">Coroutines Android Playground</string>

    <string name="active">Active</string>
    <string name="cancelling">Cancelling</string>
    <string name="cancelled">Cancelled</string>
    <string name="completed">Completed</string>

    <string name="status">Status:</string>
    <string name="parent">Parent:</string>
    <string name="child">Child:</string>
    <string name="running_time">t=<xliff:g id="time">%d</xliff:g> ms</string>
    <string name="scope_not_created">Scope not created</string>

    <!-- Contents -->
    <string name="coroutines_basics">Coroutines Basics</string>
    <string name="scopes_and_concurrency">Scopes and Concurrency</string>
    <string name="coroutine_context">Coroutine Context</string>
    <string name="flow">Flow</string>
    <string name="cancellation_and_exception_handling">Cancellation and Exception Handling</string>

    <!-- Coroutine Basics -->
    <string name="about_main_thread">The main thread also known as UI thread is responsible for rendering UI. Do not execute long running tasks on this thread as this can block the rendering and UI becomes janky by skipping frames. This problem can be solved by running these tasks on a different thread.\n\nRun a task for 500ms</string>
    <string name="run_task">Run task</string>
    <string name="use_different_thread">Use different thread</string>
    <string name="using_coroutines">Kotlin coroutines can be used to run this task in background. The task can also be run by creating a new thread but threads are expensive. Coroutines are light because they are not tied to the thread they\'re launched in. They can suspend on one thread and resume on another and when suspended they release the underlying thread to be used by other coroutines.</string>
    <string name="from_the_basics_code">
        <b>From the code:\n</b>
        <li><b>Coroutine Builder:</b> <b>launch{ }</b> is a coroutine builder used to launch a new coroutine which continues to run independently with the rest of the code.</li>\n
        <li><b>CoroutineScope:</b> Coroutines can only be launched from within a CoroutineScope which defines the lifetime of the coroutine. In the above example, <b>lifecycleScope</b> is used which is a predefined in \'lifecycle-runtime-ktx\' library.</li>\n
        <li><b>CoroutineContext:</b> Coroutines are executed in a CoroutineContext which contains a set of elements like <b>Job</b> and <b>CoroutineDispatcher</b>. Dispatchers determine which thread to be used for coroutine execution. In the above example Dispatchers.Default is used which is optimized to perform CPU intensive work.</li>
        \n\n<b>Note: </b> Running the above task in a coroutine on the main dispatcher still blocks the main thread.
    </string>

    <!-- Scopes and Concurrency -->
    <string name="scope_intro">A <b>CoroutineScope</b> defines the lifetime of coroutines launched from it. Scope is used to achieve <b>Structured Concurrency</b> and establish parent child relationships between coroutines. An outer scope completes only when all of its children coroutines complete.
        \nCode inside coroutines runs sequentially by default.
        \n\nRunning 2 tasks sequentially:
    </string>
    <string name="concurrent_tasks">Running the 2 tasks concurrently:</string>
    <string name="custom_scope"><big><b>Custom Scope</b></big>\n\nUse <b>CoroutineScope()</b> to create a custom scope and <i>cancel it when no longer needed</i> otherwise it can cause leaks. Coroutines cannot be launched in a cancelled scope.\n\nRunning task in a custom scope:</string>
    <string name="create_scope">Create Scope</string>
    <string name="cancel_scope">Cancel Scope</string>
    <string name="coroutine_scope">The <b>coroutineScope()</b> function can be used to create a scope and it inherits the context from outer scope but overrides the its Job. The function returns as soon as all children coroutines are completed. If an exception occurs within the body, this function rethrows that exception.</string>
    <string name="returned_from_function">Function returned</string>
    <string name="async"><big><b>async</b></big>\n\nasync{ } is just like launch{ } but it returns a <b>Deferred&lt;T&gt;</b> type instead which represents a promise to provide result later. Calling <b>await()</b> on the Deferred type returns the result. Deferred is a subtype of Job and inherits methods such as cancel() which is used to cancel the coroutine.
        \n\nRunning task using async:
    </string>
    <string name="lazy_async">async{ } can be started lazily by setting start parameter to <b>CoroutineStart.LAZY</b>. If set, the coroutine can be started by calling start() or await().\n\n
        Starting coroutine after 1 sec:
    </string>

    <!-- CoroutineContext -->
    <string name="coroutine_context_intro">CoroutineContext is a set of elements that define behavior of coroutine. The elements are Job, Dispatcher, CoroutineExceptionHandler and CoroutineName. Multiple elements are defined using the \'+\' operator.\n
        <li><b>Job:</b> Job is used to handle the lifecycle of the coroutine. It can be retrieved using \'coroutineContext[Job]\' expression.</li>\n
        <li><b>Coroutine Dispatcher:</b> Determines the thread for execution. Dispatchers.Main is used to run coroutine on the main thread. Dispatchers.IO is used for disk or network operations. Dispatchers.Default is used for CPU intensive work.</li>\n
        <li><b>CoroutineExceptionHandler:</b> Used to handle <i>uncaught</i> exceptions.</li>\n
        <li><b>CoroutineName:</b> Name given to a coroutine for debugging.</li>\n\nLaunching a coroutine in a new context:</string>
    <string name="throw_exception">Throw exception</string>
    <string name="job_in_coroutine_context">When a coroutine is launched using a CoroutineScope, it inherits the context from the scope and the new Job created for this coroutine is tied to the lifecycle of the scope. If the scope is cancelled, the coroutine will be cancelled too.\n\nIf a new Job instance is passed as context to the launch builder within a scope the coroutine inherits context from scope, but the new Job instance becomes the parent of the coroutine. In this case, the coroutine is not cancelled on cancelling the scope.</string>
    <string name="new_job_in_launch">New Job in launch builder</string>
    <string name="child_job_example">In the above example, the parent coroutine waits for completion of its child and then completes. When a new Job instance is passed to the launch builder, the new launched coroutine is not tied to the scope and hence operates independently. Note that the new Job instance remains in active state after the child coroutine is completed and should be cancelled in appropriate lifecycle method.</string>
    <string name="work_done">work done</string>
</resources>
